Real Python

Functions

First-Class Objects
 - In Python, functions are first-class objects. This means that functions can be passed around and used as arguments

Inner Functions

Returning Functions From Functions

Simple Decorators
 - Simple Decorators

Syntactic Sugar!
 - Instead, Python allows you to use decorators in a simpler way with the @ symbol

Reusing Decorators

Decorating Functions With Arguments

Returning Values From Decorated Functions
 - To fix this, you need to make sure the wrapper function returns the return value of the decorated function

Who Are You, Really?

A Few Real World Examples

Timing Functions

Debugging Code
 - Create a list of the positional arguments. Use repr() to get a nice string representing each argument.
 - Create a list of the keyword arguments. The f-string formats each argument as key=value where the !r specifier means that repr() is used to represent the value.
 - The lists of positional and keyword arguments is joined together to one signature string with each argument separated by a comma.
 - The return value is printed after the function is executed.

Slowing Down Code

Registering Plugins

Is the User Logged In?



** Fancy Decorators **

Decorating Classes
 - The other way to use decorators on classes is to decorate the whole class.


Nesting Decorators
 - You can apply several decorators to a function by stacking them on top of each other

Decorators With Arguments
 - Sometimes, it’s useful to pass arguments to your decorators.
 - Defining decorator_repeat() as an inner function means that repeat() will refer to a function object—decorator_repeat. Earlier, we used repeat without parentheses to refer to the function object. The added parentheses are necessary when defining decorators that take arguments.
 - The num_times argument is seemingly not used in repeat() itself. But by passing num_times a closure is created where the value of num_times is stored until it will be used later by wrapper_repeat().

Both Please, But Never Mind the Bread

Stateful Decorators
 - Sometimes, it’s useful to have a decorator that can keep track of state.

Classes as Decorators
 - In this section, you’ll see how to rewrite the @count_calls example from the previous section using a class as a decorator



** More Real World Examples **

Slowing Down Code, Revisited

Creating Singletons

Caching Return Values

Adding Information About Units

Validating JSON

Conclusion

 - They can be reused.
 - They can decorate functions with arguments and return values.
 - They can use @functools.wraps to look more like the decorated function.

**

 - Decorate classes
 - Nest decorators
 - Add arguments to decorators
 - Keep state within decorators
 - Use classes as decorators










