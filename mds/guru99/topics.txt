Introduction

 - Everything in Python is an object
 - First-Class Objects.
 - Passing Functions as Arguments to other Functions
 - Inner Functions.
 - Higher-Order Functions.



Introduction to Decorators
 - It is also called meta programming where a part of the program attempts to change another part of program at compile time
 - Syntax of Python Decorators
 - Reuse these customised behaviours on multiple functions/classes.
 - Python decorator modify data

Writing your first decorator

 - Decorating functions with parameters

How to Add Arguments to Decorators in Python

Returning Values from Decorated Functions

Reusing a Decorator on Multiple Functions

Chaining Decorators | Applying Multiple Decorators on a Single Function

A Decorator Within a Function

ADVANCED DECORATORS

Preserving function Metadata functools @wraps decorator

Decorating a Class
 - Decorators can be used with the methods of a class or the whole class.

Classes as a Decorator

 - The init function needs to take a function as an argument.
 - The class needs to implement the __call__ method. This is required because the class will be used as a decorator and a decorator must be a callable object.

 - Classes can also be used as decorators by implementing the __call__ method and passing the function to __init__ as an argument.

Built-in Fancy Decorators

 - @classmethod: It is used to create methods that are bound to the class and not the object of the class. It is shared among all the objects of that class. The class is passed as the first parameter to a class method. Class methods are often used as factory methods that can create specific instances of the class.
 - @staticmethod: Static methods can't modify object state or class state as they don't have access to cls or self. They are just a part of the class namespace.
 - @property: It is used to create getters and setters for class attributes.

Stateful Decorators
 - Sometimes, itï¿½s useful to have a decorator that can keep track of state.

Defining General Purpose Decorators

Example Use Cases of Decorators

 - Authorization
 - Logging
 - Timing Functions
 - Registering Plugins or Function Catalog
 - Caching Return Values
 - Adding Information About Units
 - Validating JSON
 - Debugging Decorators
 - Memoization
 - Synchronization

Where you dont need decorators
Singleton Class

Summary

Further reading
 - The Decorators Library in Python


